\section{System Analysis}
%\subsection{Business processes}

\subsection{Use Case Diagrams}
\subsubsection{Whole system}
The Bluetooth Mesh Chat App allows users to communicate with each other through Bluetooth connections without relying on the internet. The system consists of two main actors: the User (Actor) and the Device. The user interacts directly with the application to perform actions such as scanning for nearby devices, selecting who to chat with, and sending messages. Meanwhile, devices in the network act as peers or relays, helping transmit messages across multiple nodes to maintain connectivity in the mesh network.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Images//Usecase Diagram/UD.png}
    \caption{Usecase diagram: Whole system}
\end{figure}
The process usually begins when the user scans for nearby devices. This use case includes displaying a list of available devices and selecting one to connect with. Once connected, the user can initiate communication through the Chat without internet feature, which is the core function of the system. This use case extends other related functions such as sending messages, replying to or quoting messages, and selecting users. It represents the ability to exchange messages directly between devices without requiring mobile data or Wi-Fi.\\
When the user chooses to send a message, the system ensures efficient and reliable delivery through two important processes: Fragmentation and Reassembly, and Peer Detection. Fragmentation and reassembly handle the breaking down of large messages into smaller packets suitable for Bluetooth transmission and reassembling them correctly on the receiving device. Peer detection identifies available mesh network nodes that can receive or forward messages. If a direct connection is not possible, the system uses the Relay function, where another device helps forward the message to its destination, maintaining the mesh network’s multi-hop communication feature.\\
Beyond chatting, the user can perform several additional actions to enhance their experience. The Select user use case allows choosing specific users to chat with and can extend to features such as Block/Add to favorites, enabling users to manage their contact preferences. The app also supports Reply/quote message, which allows referencing previous messages in a conversation for clarity. Furthermore, users can edit their profiles, modifying information such as their name or visibility settings, and they can import or export chat history to save important conversations or transfer data between devices.

\subsubsection{Bootstrapping}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Images//Usecase Diagram/UD1.png}
    \caption{Usecase diagram: Bootstrapping}
\end{figure}
The Bootstrapping system begins when an outsider device initiates a scan for devices to find other nodes in its surroundings. This scanning process includes the Broadcast device presence use case, where the outsider device announces its availability to nearby devices. This broadcast allows devices already in the network to recognize and potentially connect with the outsider device. The relationship here is mutual — while the outsider device scans and broadcasts its presence, the devices in the network also listen for new broadcasts to maintain awareness of potential peers.\\
Once the broadcast is received, the devices in the network can respond in one of two ways: Accept user or Decline user. These two actions represent the decision-making step that determines whether the outsider device will be integrated into the mesh network. Both of these use cases extend from Broadcast device presence, meaning they are optional outcomes triggered depending on the system’s or user’s decision.\\
If the device is accepted, the system proceeds to update the contact database and cache. This use case ensures that the newly accepted device is stored in the network’s local memory so that future communication can occur smoothly without re-scanning or re-broadcasting. On the other hand, if the device is declined, the system still executes display user, which allows existing users or devices to view the detected outsider device without integrating it into the network. Both “accept” and “decline” include these supportive use cases to ensure proper record-keeping and user visibility.\\

\subsubsection{Open single communication channel}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Images//Usecase Diagram/UD2.png}
    \caption{Usecase diagram: Open single communication channel}
\end{figure}
When a user performs the Display peers use case, the process begins. This step allows the initiating user to view nearby or available peers within Bluetooth range or reachable via the mesh network. Once peers are displayed, the user proceeds to choose a peer, selecting a specific device or person they wish to communicate with. This marks the start of an attempt to open a single, direct communication channel between the two devices.\\
After choosing a peer, the system transitions to a decision phase involving two possible actions: Accept user or Decline user. These two use cases extend from Choose peer, as they are conditional outcomes that depend on how the receiving user responds to the connection request. If the receiving user accepts the request, the system proceeds with the Establish secure channel use case, which ensures that the communication link is encrypted and authenticated to prevent unauthorized access or data interception. This step is essential in maintaining privacy and trust between users in a Bluetooth-based mesh network.\\
Whether the request is accepted or declined, the system also includes the Notify user use case. This function ensures that the initiating user is informed about the outcome of their connection request — whether the communication channel has been successfully established or denied. Both “accept user” and “decline user” include this notification feature, ensuring that users receive consistent feedback on their connection attempts.\\

\subsubsection{Process message}
When a device receives a packet from another peer, the process begins with the Receive packet use case. This represents the system’s initial handling of incoming data. Immediately after receiving, the system executes Decrease packet TTL (Time To Live) and Check packet TTL, which are both included in use cases. The TTL value determines how many hops a packet can make before being discarded, preventing infinite circulation within the mesh. If the TTL reaches zero, the system executes the Drop packet use case, ending the process for that data unit.\\
If the packet remains valid (TTL > 0), the system proceeds to <Check packet> information. This step involves inspecting the packet’s metadata — such as sender ID, destination ID, and sequence number — to determine whether it should be processed or ignored. Several optional or conditional actions extend from this stage. For instance, the <Check block list> ensures that packets from blocked or banned devices are filtered out. Check packet cache prevents duplicate message forwarding by verifying whether the packet has already been processed or forwarded recently. Both checks help maintain security and reduce unnecessary traffic in the mesh network.\\
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Usecase Diagram/UD3.png}
    \caption{Usecase diagram: Process message}
\end{figure}
Once the packet passes these checks, the system moves to Accept packet, which indicates that the packet is legitimate and ready to be processed or forwarded. Accepting the packet includes <Update packet/contact database>, cache, allowing the system to store new peer information and maintain an updated record of recently seen packets and nodes. This helps optimize future routing decisions.\\
After the packet is accepted, the device must determine how to deliver or relay it. This is handled through the Confirm packet path use case, which validates the intended destination. Depending on the routing outcome, the system may <Broadcast packet> — forwarding it to multiple peers to reach unknown destinations — or <Unicast to known peer>, sending it directly to a specific device if the path is already known. Both of these cases extend from the <Confirm packet path> since they are conditional forwarding strategies determined by the mesh routing logic.\\

\subsubsection{Send message}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Usecase Diagram/UD4.png}
    \caption{Usecase diagram: Send message}
\end{figure}
The process starts when the user initiates the <Type message in the channel> use case. This represents composing a message in the chat interface. Once the user types a message, the system automatically proceeds to <Form packet>, which packages the message content along with necessary metadata such as source ID, destination ID, timestamp, and sequence number. This use case is included because packet formation is always required before any transmission can occur.\\
After the packet is formed, the system performs two parallel verification checks — Check packet cache and Check peer cache. Checking the packet cache ensures that the message is not a duplicate of a recently sent or processed packet, preventing redundancy and network congestion. At the same time, checking the peer cache verifies that the target peer or device is known and that its address and status are stored locally. Both of these are included in use cases, as they are standard procedures during message preparation.\\
Next, the system proceeds to confirm the packet’s routing and the recipient’s readiness. The Confirm packet’s path use case determines whether a valid route exists for message delivery. If a known path is available, the message may be <unicasted to known peer>, representing direct one-to-one delivery within the mesh. If no known route exists or if the destination is uncertain, the system may instead broadcast the message, extending its reach to all nearby nodes, which can forward it until it reaches the intended peer. Both <Broadcast message> and <Unicast to known peer> are extended use cases since they are conditional on the outcome of path confirmation.\\
In parallel, the <Confirm peer’s availability> use case checks whether the target peer is currently reachable in the network. This extends from <Check peer cache> and helps the system avoid transmission failures. If the peer is temporarily unavailable (for example, disconnected or out of range), the system triggers the <Buffer message> until the available use case, which temporarily stores the message and retries sending when the peer reconnects. This ensures reliability and prevents message loss even in a dynamic mesh environment.

\subsubsection{Fragmentation}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{Images//Usecase Diagram/UD5.png}
    \caption{Usecase diagram: Fragmentation}
\end{figure}
The main actor here is the device, which could be any node in the mesh network (either a sender or a relay). The process begins when the device <Receives data>, such as a message or file, that needs to be prepared for transmission. This is the primary use case of the diagram.\\
Once the data is received, the system automatically triggers the Check data size against threshold use case. This step compares the incoming data’s size with the system’s predefined maximum transmission unit (MTU). If the data size exceeds this threshold, the system must perform fragmentation to ensure compatibility with the mesh network’s transmission constraints. This relationship is modeled as an include, since checking data size is an essential step every time data is received.\\
If the threshold check determines that fragmentation is needed, the Break data into smaller predefined chunks use case is invoked. This represents dividing the original message into smaller pieces that conform to the mesh packet size limit. Each chunk is then assigned an identifier and sequence number to allow proper reassembly at the receiver’s end. This step is also shown as an include, as it is a required sub-process once large data is detected.\\
After fragmentation or if the data already fits within the size limit, the process proceeds to Form packet, which organizes the (possibly fragmented) data into transmission-ready packets that include addressing, integrity checks, and sequence metadata. This ensures that the resulting packets can be efficiently propagated through the mesh. The Form packet use case is central to this process and is therefore included in both <Receive data> and <Break data into chunks>.

\subsubsection{Form packet}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{Images//Usecase Diagram/UD6.png}
    \caption{Usecase diagram: Form packet}
\end{figure}
The process begins when the device <Receives data/request>, which could originate from higher-level processes such as user input, fragmented data chunks, or control messages. This initial step triggers the packet formation process and is marked as an include relationship since it is always necessary for forming a packet.\\
After receiving the data, the system proceeds to <Fill out packet header>, where it constructs the essential components of the packet’s metadata — such as source and destination addresses, message type, sequence number, and other routing-related information. This header ensures that each packet can be properly routed through the mesh and identified upon reception.\\
The <Create signature through metadata> use case is shown as an extension of the header-filling step. This indicates that once the header is completed, the system may generate a digital signature or integrity check based on the metadata. This mechanism ensures authenticity and prevents tampering during transmission across multiple mesh hops.
To further enhance security, the <Encrypt data with session key> use case is introduced as another extended relationship. This step ensures that the payload is encrypted before transmission using a shared session key between peers. This encryption maintains confidentiality, ensuring that only authorized nodes can read the message contents even though the mesh operates as a distributed network.\\
Once the packet has been properly constructed, signed, and encrypted, it is ready to be transmitted. The Send packet to transport layer use case — connected via an include relationship — handles forwarding the completed packet to the underlying transport layer. This layer then manages the packet’s transmission across the mesh network, whether via unicast or broadcast, depending on the routing configuration.

\subsection{Activity Diagrams}
\begin{wrapfigure}{r}{0.6\textwidth}
  \begin{center}
    \includegraphics[width=0.2\textwidth]{Images//Activity Diagram/AD1.png}
  \end{center}
  \caption{Activity diagram: Bootstrapping}
\end{wrapfigure}
The app continuously scans nearby devices over Bluetooth and reads each peer’s basic info from advertisements/GATT while also broadcasting its own presence. When the user accepts a peer, the app fetches that peer’s network details (e.g., capabilities/keys), then updates a local peer cache with a fresh timestamp/TTL. If the user declines, the temporary record is discarded. The UI then displays the current list of discovered users. This loop repeats so the list stays up-to-date as devices appear or leave.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{Images//Activity Diagram/AD2.png}
    \caption{Activity diagram: Open communication channel}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Images//Activity Diagram/AD3.png}
    \caption{Activity diagram: Process message}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Images//Activity Diagram/AD4.png}
    \caption{Activity diagram: Send message}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Images//Activity Diagram/AD5.png}
    \caption{Activity diagram: Fragmentation}
\end{figure}
\begin{figure}[H]
    \centering  
    \includegraphics[width=0.5\linewidth]{Images//Activity Diagram/AD6.png}
    \caption{Activity diagram: Form packet}
\end{figure}

\subsection{\mbox{Sequence Diagram}}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Images//Sequence diagram/Bootstrapping.png}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Sequence diagram/Open communication channel.png}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Sequence diagram/Process message.png}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Sequence diagram/Send message.png}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Sequence diagram/Fragmentation.png}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Sequence diagram/Form Packet.png}
\end{figure}

\subsection{\mbox{Deployment Diagram}}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/Deployment Diagram/Deployment Diagram.drawio.png}
\end{figure}
This diagram shows the execution architecture of the hardware system and the assignment of software artifacts to the hardware. Each device (smartphone) runs the app, which includes several components: Interface, Mesh manager, Encryption engine, Data cache (message queue, encryption keys, etc). Devices communicate directly using BLE in a mesh topology. The Mesh manager handles discovery, relaying, and routing of the payload while the encryption engine keeps things private.

\subsection{Class Diagram}
The Class Diagram illustrated depicts the static structure of the system, defining the attributes, operations, and relationships between the core components.

This diagram combines the entities defined in the sequence diagrams into a unified architectural model. Key components include:
\begin{itemize}
    \item \textbf{UI Layer:} Represented by the \texttt{User} and \texttt{ChatBox} classes, handling user interactions.
    \item \textbf{Mesh Logic:} The \texttt{MeshManager} acts as the central controller, coordinating with \texttt{BootstrappingController} for node discovery.
    \item \textbf{Data Handling:} The \texttt{MessageProcessor} delegates specialized tasks to the \texttt{SecurityHandler} (encryption) and \texttt{FragmentationHandler} (packet sizing).
    \item \textbf{Storage:} \texttt{ChatStorage} and \texttt{Cache} provide local persistence for messages and routing tables, essential for the offline capability.
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{Images/Class Diagram/Class Diagram.png} 
    \caption{System Class Diagram showing the relationships between the Mesh Manager, Controllers, and Data Entities.}
    \label{fig:class_diagram}
\end{figure}