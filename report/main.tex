\documentclass[12pt,a4paper]{article}
% \usepackage[english, vietnam]{babel}
\usepackage[T5,T1]{fontenc}
% \usepackage{mathptmx}[ptm]
%\usepackage[utf8]{inputenc}
\usepackage[utf8]{vietnam}
%\usepackage[francais]{babel}
\usepackage{a4wide,amssymb,epsfig,latexsym,array,hhline,fancyhdr}
\usepackage[american]{babel}
\usepackage{csquotes}
\usepackage[style=apa, citestyle=numeric, backend=biber, sorting=none]{biblatex}
% \usepackage{apacite}
\usepackage[toc,page]{appendix}
\usepackage{pifont,amssymb}
\usepackage{sectionbreak}
\newcommand{\emptysquare}{$\square$}
\newcommand{\checkedsquare}{\makebox[0pt][l]{\raisebox{1pt}[0pt][0pt]{\large\hspace{1pt}\cmark}}$\square$}
\newcommand{\cmark}{\ding{51}}

\DeclareFieldFormat{labelnumberwidth}{\mkbibbrackets{#1}}

\defbibenvironment{bibliography}
  {\list
     {\printtext[labelnumberwidth]{%
      \printfield{labelprefix}%
      \printfield{labelnumber}}}
     {\setlength{\labelwidth}{\labelnumberwidth}%
      \setlength{\leftmargin}{\labelwidth}%
      \setlength{\labelsep}{\biblabelsep}%
      \addtolength{\leftmargin}{\labelsep}%
      \setlength{\itemsep}{\bibitemsep}%
      \setlength{\parsep}{\bibparsep}}%
      \renewcommand*{\makelabel}[1]{\hss##1}}
  {\endlist}
  {\item}

\addbibresource{newrefs.bib}
% \newcommand*{\captionsource}[2]{%
% \centering
%   \caption[{#1}]{%
%     #1%
%     \\\hspace{\linewidth}%
%     \textbf{Source:} #2%
%   }%
% }

\usepackage{vcell}
\usepackage{tabularray}
%\usepackage{soul}

\usepackage[makeroom]{cancel}
\usepackage{amsmath}
\usepackage{wrapfig}
\usepackage{amsthm}
\usepackage{multicol,longtable,amscd}
\usepackage{diagbox}%Make diagonal lines in tables
\usepackage{booktabs}
\usepackage{alltt}
\usepackage[framemethod=tikz]{mdframed}% For highlighting paragraph backgrounds
\usepackage{caption,subcaption}
\usepackage{float}
\usepackage{lastpage}
\usepackage[lined,boxed,commentsnumbered]{algorithm2e}
\usepackage{enumerate}
\usepackage{color}
\usepackage{graphicx}							% Standard graphics package
\usepackage{array}
\usepackage{tabularx, caption}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{rotating}
\usepackage{graphics}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{epsfig}
\usepackage{tikz}
\usepackage{titlesec}
\usepackage{url}
\usepackage{ragged2e}
\usepackage{makecell}
% \usepackage[style=apa]{biblatex}
% \usepackage{natbib}
% \bibliographystyle{ieeetr}

\usetikzlibrary{arrows,snakes,backgrounds,calc}
\usepackage{hyperref}
\hypersetup{urlcolor=blue,linkcolor=black,citecolor=black,colorlinks=true}
\usepackage{listings}


%\usepackage{pstcol} 								% PSTricks with the standard color package

\usepackage[normalem]{ulem}

\newtheorem{theorem}{{\bf Định lý}}
\newtheorem{property}{{\bf Tính chất}}
\newtheorem{proposition}{{\bf Mệnh đề}}
\newtheorem{corollary}[proposition]{{\bf Hệ quả}}
\newtheorem{lemma}[proposition]{{\bf Bổ đề}}
\theoremstyle{definition}
\newtheorem{exer}{Bài toán}

\def\thesislayout{	% A4: 210 × 297
	\geometry{
		a4paper,
		total={160mm,240mm},  % fix over page
		left=30mm,
		top=30mm,
	}
}
\def\thesisheadlayout{	% A4: 210 × 297
	\geometry{
		a4paper,
		total={160mm,240mm},  % fix over page
		left=30mm,
		top=10mm,
	}
}
\thesislayout
\lstset{
    language=R,
    basicstyle=\footnotesize\sffamily,
    commentstyle=\ttfamily\color{black},
    numbers=left,
    numberstyle=\ttfamily\color{black}\footnotesize,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    title=\lstname,
    escapeinside={},
    keywordstyle={},
    morekeywords={}
}
%\usepackage{fancyhdr}
\setlength{\headheight}{40pt}
\pagestyle{fancy}
\fancyhead{} % clear all header fields
\fancyhead[L]{
 \begin{tabular}{rl}
    \begin{picture}(25,15)(0,0)
    \put(0,-8){\includegraphics[width=12mm, height=12mm]{Images/hcmut.png}}
    %\put(0,-8){\epsfig{width=10mm,figure=hcmut.eps}}
   \end{picture}&
	%\includegraphics[width=12mm, height=12mm]{hcmut.png} & %
	\begin{tabular}{l}
		\textbf{  Ho Chi Minh City University of Technology }\\
		\textbf{  Faculty of Computer Science and Engineering }
	\end{tabular} 	
 \end{tabular}
}
\fancyhead[R]{
	\begin{tabular}{l}
		\tiny \bf \\
		\tiny \bf 
	\end{tabular}  }
\fancyfoot{} % clear all footer fields
\fancyfoot[L]{\scriptsize  Specialized project report}
\fancyfoot[R]{\scriptsize  Page {\thepage}/\pageref{LastPage}}
\renewcommand{\headrulewidth}{0.3pt}
\renewcommand{\footrulewidth}{0.3pt}


%%%
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{3}
\makeatletter
\newcounter {subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection .\@alph\c@subsubsubsection}
\newcommand\subsubsubsection{\@startsection{subsubsubsection}{4}{\z@}%
                                     {-3.25ex\@plus -1ex \@minus -.2ex}%
                                     {1.5ex \@plus .2ex}%
                                     {\normalfont\normalsize\bfseries}}
\newcommand*\l@subsubsubsection{\@dottedtocline{3}{7.0em}{4.1em}}
\newcommand*{\subsubsubsectionmark}[1]{}
\makeatother

\everymath{\color{black}}%make in-line maths symbols blue to read/check easily

\sloppy
\captionsetup[figure]{labelfont={small,bf},textfont={small,it},belowskip=-1pt,aboveskip=5pt}
%space remove between caption, figure, and text
\captionsetup[table]{labelfont={small,bf},textfont={small,it},belowskip=-1pt,aboveskip=7pt}
\setlength{\floatsep}{5pt plus 2pt minus 2pt}
\setlength{\textfloatsep}{5pt plus 2pt minus 2pt}
\setlength{\intextsep}{10pt plus 2pt minus 2pt}
\DeclareTextFontCommand{\textvietnamese}{\fontencoding{T5}\selectfont}

\thesislayout

%% Spacings
\onehalfspacing     % spacing between lines
\setlength{\parskip}{7.5pt} % between paragraphs
\setlength{\parindent}{7pt} % new para indentation
\titlespacing*{\section}{0pt}{0pt}{0pt}
\titlespacing*{\subsection}{0pt}{0pt}{0pt}
\titlespacing*{\subsubsection}{0pt}{0pt}{0pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\begin{titlepage}
\begin{tikzpicture}[remember picture, overlay]
  \draw[line width = 4pt] ($(current page.north west) + (0.4in,-0.5in)$) rectangle ($(current page.south east) + (-0.4in,0.5in)$);
  \draw[line width=1.5pt]
    ($ (current page.north west) + (0.45in,-0.55in) $)
    rectangle
    ($ (current page.south east) + (-0.45in,0.55in) $);
\end{tikzpicture}

\begin{singlespace}
\vspace{-2cm}
\begin{center}
\fontsize{15}{12} \textbf{Vietnam National University Ho Chi Minh City} \\
\vspace{0.2cm}
\fontsize{15}{12} \textbf{University of Technology} \\
\vspace{0.2cm}
\fontsize{15}{12} \textbf{Faculty of Computer Science and Engineering}
\end{center}
\end{singlespace}

\vspace{0.2cm}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=5cm]{Images/hcmut.png}
\end{center}
\end{figure}

\vspace{0.3cm}

\begin{center}
\fontsize{15}{12} \textbf{SPECIALIZED PROJECT}  \\ 
\fontsize{15}{12} \textbf{REPORT}  \\ 
\end{center}

\vspace{0.5cm}

\begin{center}
    \setstretch{1.9}\fontsize{23}{12} \textbf{ENCRYPTED PEER-TO-PEER MESSAGING APP OVER BLUETOOTH MESH NETWORKS} \\
    \vspace{0.5em}
    \fontsize{15}{12}\selectfont Major: Computer Science \\
\end{center}

\vspace{0.5cm}

\begin{center}
\fontsize{15}{12}\selectfont{
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{rl}
    \textbf{THESIS COMMITTEE:} & HCMUT. CompSience Council  \\
    \textbf{SUPERVISOR:} & Assoc. Prof. Trương Tuấn Anh, PhD  \\
    \multicolumn{2}{c}{\textbf{---o0o---}} \\
    \textbf{STUDENT 1:} & Trần Trung Vĩnh (2252914) \\
    \textbf{STUDENT 2}: & Nguyễn Trần Huy Việt (2252906) \\
    \textbf{STUDENT 3:} & Nguyễn Anh Quân (2252678) \\
    \textbf{STUDENT 4:} & Lê Phan Nhật Minh (2252478)
    
\end{tabular}
}
\end{center}

\vspace{2.2cm}

\begin{center}
    \fontsize{15}{12}\selectfont Ho Chi Minh City, October 2025
\end{center}
\end{titlepage}



% \vspace{2\baselineskip}

% \noindent\rule{4in}{0.7pt} \hfill \rule{1.5in}{0.7pt}

% \noindent Darth Sion\\
% Professor, Department of Chemistry and Biochemistry\\
% University of Sichuan Gourmet Kitchen\\
% Thesis Committee

% \vspace{2\baselineskip}

% (etc.)
\newpage
\begin{center}
    \textbf{\Large PROTESTATION}
\end{center}

\par\hfill\textbf{Authors}\hspace{1cm}
\par\hfill\textit{Trần Trung Vĩnh}
\par\hfill\textit{Nguyễn Trần Huy Việt}
\par\hfill\textit{Nguyễn Anh Quân}
\par\hfill\textit{Lê Phan Nhật Minh}
\newpage

\begin{center}
    \textbf{\Large ACKNOWLEDGEMENTS}
\end{center}

\par\hfill\textbf{Authors}\hspace{1cm}
\par\hfill\textit{Trần Trung Vĩnh}
\par\hfill\textit{Nguyễn Trần Huy Việt}
\par\hfill\textit{Nguyễn Anh Quân}
\par\hfill\textit{Lê Phan Nhật Minh}
\newpage

\begin{center}
    \textbf{\Large Abstract}
\end{center}
This project presents the design and development of a decentralized messaging and file-sharing application using a Bluetooth mesh network. The system enables communication in environments where conventional internet or cellular networks are unavailable, such as during natural disasters, protests, large public gatherings, or remote outdoor activities. The application supports peer-to-peer encrypted messaging and secure file transfers, ensuring user privacy and data protection. To enhance reliability and scalability, it utilizes multiple data transmission techniques—including relay, hopping, and flooding—allowing messages to propagate efficiently across devices within the mesh network. This solution demonstrates how local wireless connectivity can be leveraged to create a resilient, infrastructure-independent communication platform for emergency and off-grid scenarios.
\newpage

\begin{singlespace}
\tableofcontents
\end{singlespace}
\newpage

\begin{singlespace}
\listoffigures
\end{singlespace}
\newpage

\begin{singlespace}
\listoftables
\end{singlespace}
\newpage

\section{Introduction}
\subsection{Motivation}
In recent years, the increasing reliance on centralized communication infrastructures has exposed significant vulnerabilities during emergencies and connectivity outages. Natural disasters, political unrest, and network restrictions often render traditional internet-based communication useless, leaving people isolated and unable to coordinate or request help.  
Furthermore, growing privacy concerns highlight the risks of centralized servers that can collect, monitor, or expose user data.  

This project is motivated by the need for a secure, privacy-preserving, and infrastructure-independent communication system. By leveraging Bluetooth Mesh technology and end-to-end encryption, the proposed system enables direct, resilient, and private communication between users, even in the absence of mobile networks or Wi-Fi.


\subsection{Objectives}
The primary objectives of this project are as follows:

\begin{itemize}
    \item \textbf{To design and develop} a decentralized peer-to-peer messaging application using Bluetooth Mesh communication.
    \item \textbf{To ensure security and privacy} through end-to-end encryption, authentication, and integrity protection.
    \item \textbf{To support offline communication} in environments where internet or cellular networks are unavailable or unreliable.
    \item \textbf{To optimize performance and battery efficiency} by using Bluetooth Low Energy (BLE) for background operation.
    \item \textbf{To provide a user-friendly interface} that allows non-technical users to communicate easily without complex setup.
    \item \textbf{To evaluate system scalability and reliability} across different real-world use cases such as disaster zones, remote communities, and crowded public events.
\end{itemize}
\subsection{Scope}
The scope of this project includes the design, implementation, and testing of a Bluetooth Mesh-based communication system that enables short- to medium-range peer-to-peer messaging. The project focuses on local device-to-device networking without reliance on internet or mobile infrastructure.  

Key features within the project scope include:
\begin{itemize}
    \item Bluetooth Mesh message routing, node discovery, and relay functionality.
    \item End-to-end encryption for all transmitted data.
    \item Text and small media (e.g., image) message exchange.
    \item Android-based implementation using Kotlin and BLE APIs.
\end{itemize}

Out of scope for this project:
\begin{itemize}
    \item Integration with cloud or server-based systems.
    \item Long-range or cross-network message relaying via the internet.
    \item Support for iOS or other operating systems in the current version (planned for future expansion).
\end{itemize}

The project will thus deliver a fully functional Android prototype demonstrating secure, decentralized, and offline communication over Bluetooth Mesh networks.
\subsection{Significance of the Project}

\subsubsection{Significance from the Practical Perspectives}

\subsubsection{Significance from the Scientific Perspectives}

\subsection{Report structure}

\newpage
\section{Background Knowledge}

\newpage
\section{Technology Stack}

\newpage
\section{Related Works}

\newpage
\section{Requirements Elicitation}
\subsection{System users}


\subsection{Functional requirements}
\subsubsection*{User Requirements}
\begin{enumerate}[label=\textbf{U\arabic*.}]
    \item \textbf{Bootstrapping:} Upon launching the application, the system shall automatically initiate device discovery and implicitly integrate nearby compatible devices into the mesh network without requiring manual configuration.
    \item \textbf{Offline Chat:} Users shall be able to chat without an Internet connection.
    \item \textbf{Peer Selection:} Users shall be able to choose who to chat with when the app detects nearby peers.
    \item \textbf{User Profile:} Users shall be able to choose and change their nickname and profile picture.
    \item \textbf{Favorites and Blocking:} Users shall be able to mark another person as a favorite or block them.
    \item \textbf{Broadcast Messaging:} Users shall be able to send broadcast messages to nearby users (e.g., emergency alerts or announcements).
    \item \textbf{Reply and Quote:} Users shall be able to reply to or quote specific messages.
    \item \textbf{Chat History:} The system shall support chat history backup and export.
    \item \textbf{Notifications:} The system shall provide chat notifications.
    \item \textbf{Mute Options:} Users shall be able to mute group or peer notifications.
    \item \textbf{Tutorial/Onboarding:} The system shall provide a tutorial or onboarding flow for first-time users.
    \item \textbf{Appearance:} The system shall support dark mode and accessibility options.
    \item \textbf{Relay Functionality:} The user’s device must help forward messages to other peers if it is not the destination.
    \item \textbf{Peer Detection:} The system shall continuously monitor and maintain awareness of all active devices within the mesh network.
    \item \textbf{Battery Saving:} The system shall provide a battery-saving mode.
    \item \textbf{File Sharing:} The system shall support file sharing between users.
\end{enumerate}

\subsubsection*{Group Requirements (Optional for this semester)}
\begin{enumerate}[label=\textbf{G\arabic*.}]
    \item Users shall be able to create a group chat with multiple peers.
    \item The group chat creator is a \textbf{Leader} and can appoint \( n-2 \) more \textbf{Co-Leaders}, where \( n \) is the total number of members.
    \item Leaders and Co-Leaders can swap roles with members who have lower roles.
    \item Leaders and Co-Leaders can set group chat status as:
    \begin{itemize}
        \item \textbf{Open} – anyone can join
        \item \textbf{Restricted} – users must request to join
        \item \textbf{Closed} – only whitelisted users can join
    \end{itemize}
    \item All peers can join or request to join groups and can also leave groups.
    \item Join/Leave actions shall be displayed in the group.
    \item Leaders and Co-Leaders can:
    \begin{itemize}
        \item Add or remove members
        \item Change the group’s name and profile picture
    \end{itemize}
    \item The system shall support polls or voting for group decisions.
    \item The system shall support group event scheduling (e.g., meetups in remote areas).
\end{enumerate}

\subsection{Non-Functional Requirements}

\subsubsection*{Security}
\begin{enumerate}[label=\textbf{S\arabic*.}]
    \item All messages and data must be encrypted end-to-end using a secure protocol.
    \item The system must ensure message and data traceability by reliably associating each transmission with its originating sender.
    \item The system shall guarantee data integrity by preventing unauthorized modification or tampering.
    \item The system shall support self-destructing messages or message expiration after 24 hours for sensitive communication.
\end{enumerate}

\subsubsection*{Scalability}
\begin{enumerate}[label=\textbf{SC\arabic*.}]
    \item The system must be able to handle a network of 100–500 nodes.
\end{enumerate}

\subsubsection*{Reliability}
\begin{enumerate}[label=\textbf{R\arabic*.}]
    \item The system must detect whether data has been successfully transferred.
    \item The system must synchronize data between peers once both are online again.
\end{enumerate}

\subsubsection*{Performance}
\begin{enumerate}[label=\textbf{P\arabic*.}]
    \item Peer discovery should complete within 5 seconds under typical mesh conditions.
    \item Message delivery latency should be under 1 second for nearby peers.
\end{enumerate}

\subsubsection*{Archivability}
\begin{enumerate}[label=\textbf{A\arabic*.}]
    \item The system shall persistently store user-associated messages on the user's device until explicitly deleted or modified by user-defined retention settings.
    \item Messages not directly associated with the user shall be temporarily cached for up to 24 hours and automatically forwarded upon detection of the recipient's availability. Once delivered, cached messages shall be deleted automatically.
\end{enumerate}

\subsubsection*{Efficiency}
\begin{enumerate}[label=\textbf{E\arabic*.}]
    \item The app must minimize battery usage during idle mesh scanning.
    \item Each message shall be limited to 1024 characters.
    \item Bluetooth transmissions should be optimized to reduce unnecessary chatter.
\end{enumerate}

\subsection{Data requirements}

\newpage
\section{System Analysis}
%\subsection{Business processes}

\subsection{Use Case Diagrams}
\subsubsection{Whole system}
The Bluetooth Mesh Chat App allows users to communicate with each other through Bluetooth connections without relying on the internet. The system consists of two main actors: the User (Actor) and the Device. The user interacts directly with the application to perform actions such as scanning for nearby devices, selecting who to chat with, and sending messages. Meanwhile, devices in the network act as peers or relays, helping transmit messages across multiple nodes to maintain connectivity in the mesh network.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Images//Usecase Diagram/UD.png}
    \caption{Usecase diagram: Whole system}
\end{figure}
The process usually begins when the user scans for nearby devices. This use case includes displaying a list of available devices and selecting one to connect with. Once connected, the user can initiate communication through the Chat without internet feature, which is the core function of the system. This use case extends other related functions such as sending messages, replying to or quoting messages, and selecting users. It represents the ability to exchange messages directly between devices without requiring mobile data or Wi-Fi.\\
When the user chooses to send a message, the system ensures efficient and reliable delivery through two important processes: Fragmentation and Reassembly, and Peer Detection. Fragmentation and reassembly handle the breaking down of large messages into smaller packets suitable for Bluetooth transmission and reassembling them correctly on the receiving device. Peer detection identifies available mesh network nodes that can receive or forward messages. If a direct connection is not possible, the system uses the Relay function, where another device helps forward the message to its destination, maintaining the mesh network’s multi-hop communication feature.\\
Beyond chatting, the user can perform several additional actions to enhance their experience. The Select user use case allows choosing specific users to chat with and can extend to features such as Block/Add to favorites, enabling users to manage their contact preferences. The app also supports Reply/quote message, which allows referencing previous messages in a conversation for clarity. Furthermore, users can edit their profiles, modifying information such as their name or visibility settings, and they can import or export chat history to save important conversations or transfer data between devices.

\subsubsection{Bootstrapping}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Images//Usecase Diagram/UD1.png}
    \caption{Usecase diagram: Bootstrapping}
\end{figure}
The Bootstrapping system begins when an outsider device initiates a scan for devices to find other nodes in its surroundings. This scanning process includes the Broadcast device presence use case, where the outsider device announces its availability to nearby devices. This broadcast allows devices already in the network to recognize and potentially connect with the outsider device. The relationship here is mutual — while the outsider device scans and broadcasts its presence, the devices in the network also listen for new broadcasts to maintain awareness of potential peers.\\
Once the broadcast is received, the devices in the network can respond in one of two ways: Accept user or Decline user. These two actions represent the decision-making step that determines whether the outsider device will be integrated into the mesh network. Both of these use cases extend from Broadcast device presence, meaning they are optional outcomes triggered depending on the system’s or user’s decision.\\
If the device is accepted, the system proceeds to update the contact database and cache. This use case ensures that the newly accepted device is stored in the network’s local memory so that future communication can occur smoothly without re-scanning or re-broadcasting. On the other hand, if the device is declined, the system still executes display user, which allows existing users or devices to view the detected outsider device without integrating it into the network. Both “accept” and “decline” include these supportive use cases to ensure proper record-keeping and user visibility.\\

\subsubsection{Open single communication channel}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Images//Usecase Diagram/UD2.png}
    \caption{Usecase diagram: Open single communication channel}
\end{figure}
When a user performs the Display peers use case, the process begins. This step allows the initiating user to view nearby or available peers within Bluetooth range or reachable via the mesh network. Once peers are displayed, the user proceeds to choose a peer, selecting a specific device or person they wish to communicate with. This marks the start of an attempt to open a single, direct communication channel between the two devices.\\
After choosing a peer, the system transitions to a decision phase involving two possible actions: Accept user or Decline user. These two use cases extend from Choose peer, as they are conditional outcomes that depend on how the receiving user responds to the connection request. If the receiving user accepts the request, the system proceeds with the Establish secure channel use case, which ensures that the communication link is encrypted and authenticated to prevent unauthorized access or data interception. This step is essential in maintaining privacy and trust between users in a Bluetooth-based mesh network.\\
Whether the request is accepted or declined, the system also includes the Notify user use case. This function ensures that the initiating user is informed about the outcome of their connection request — whether the communication channel has been successfully established or denied. Both “accept user” and “decline user” include this notification feature, ensuring that users receive consistent feedback on their connection attempts.\\

\subsubsection{Process message}
When a device receives a packet from another peer, the process begins with the Receive packet use case. This represents the system’s initial handling of incoming data. Immediately after receiving, the system executes Decrease packet TTL (Time To Live) and Check packet TTL, which are both included in use cases. The TTL value determines how many hops a packet can make before being discarded, preventing infinite circulation within the mesh. If the TTL reaches zero, the system executes the Drop packet use case, ending the process for that data unit.\\
If the packet remains valid (TTL > 0), the system proceeds to <Check packet> information. This step involves inspecting the packet’s metadata — such as sender ID, destination ID, and sequence number — to determine whether it should be processed or ignored. Several optional or conditional actions extend from this stage. For instance, the <Check block list> ensures that packets from blocked or banned devices are filtered out. Check packet cache prevents duplicate message forwarding by verifying whether the packet has already been processed or forwarded recently. Both checks help maintain security and reduce unnecessary traffic in the mesh network.\\
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Usecase Diagram/UD3.png}
    \caption{Usecase diagram: Process message}
\end{figure}
Once the packet passes these checks, the system moves to Accept packet, which indicates that the packet is legitimate and ready to be processed or forwarded. Accepting the packet includes <Update packet/contact database>, cache, allowing the system to store new peer information and maintain an updated record of recently seen packets and nodes. This helps optimize future routing decisions.\\
After the packet is accepted, the device must determine how to deliver or relay it. This is handled through the Confirm packet path use case, which validates the intended destination. Depending on the routing outcome, the system may <Broadcast packet> — forwarding it to multiple peers to reach unknown destinations — or <Unicast to known peer>, sending it directly to a specific device if the path is already known. Both of these cases extend from the <Confirm packet path> since they are conditional forwarding strategies determined by the mesh routing logic.\\

\subsubsection{Send message}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Usecase Diagram/UD4.png}
    \caption{Usecase diagram: Send message}
\end{figure}
The process starts when the user initiates the <Type message in the channel> use case. This represents composing a message in the chat interface. Once the user types a message, the system automatically proceeds to <Form packet>, which packages the message content along with necessary metadata such as source ID, destination ID, timestamp, and sequence number. This use case is included because packet formation is always required before any transmission can occur.\\
After the packet is formed, the system performs two parallel verification checks — Check packet cache and Check peer cache. Checking the packet cache ensures that the message is not a duplicate of a recently sent or processed packet, preventing redundancy and network congestion. At the same time, checking the peer cache verifies that the target peer or device is known and that its address and status are stored locally. Both of these are included in use cases, as they are standard procedures during message preparation.\\
Next, the system proceeds to confirm the packet’s routing and the recipient’s readiness. The Confirm packet’s path use case determines whether a valid route exists for message delivery. If a known path is available, the message may be <unicasted to known peer>, representing direct one-to-one delivery within the mesh. If no known route exists or if the destination is uncertain, the system may instead broadcast the message, extending its reach to all nearby nodes, which can forward it until it reaches the intended peer. Both <Broadcast message> and <Unicast to known peer> are extended use cases since they are conditional on the outcome of path confirmation.\\
In parallel, the <Confirm peer’s availability> use case checks whether the target peer is currently reachable in the network. This extends from <Check peer cache> and helps the system avoid transmission failures. If the peer is temporarily unavailable (for example, disconnected or out of range), the system triggers the <Buffer message> until the available use case, which temporarily stores the message and retries sending when the peer reconnects. This ensures reliability and prevents message loss even in a dynamic mesh environment.

\subsubsection{Fragmentation}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{Images//Usecase Diagram/UD5.png}
    \caption{Usecase diagram: Fragmentation}
\end{figure}
The main actor here is the device, which could be any node in the mesh network (either a sender or a relay). The process begins when the device <Receives data>, such as a message or file, that needs to be prepared for transmission. This is the primary use case of the diagram.\\
Once the data is received, the system automatically triggers the Check data size against threshold use case. This step compares the incoming data’s size with the system’s predefined maximum transmission unit (MTU). If the data size exceeds this threshold, the system must perform fragmentation to ensure compatibility with the mesh network’s transmission constraints. This relationship is modeled as an include, since checking data size is an essential step every time data is received.\\
If the threshold check determines that fragmentation is needed, the Break data into smaller predefined chunks use case is invoked. This represents dividing the original message into smaller pieces that conform to the mesh packet size limit. Each chunk is then assigned an identifier and sequence number to allow proper reassembly at the receiver’s end. This step is also shown as an include, as it is a required sub-process once large data is detected.\\
After fragmentation or if the data already fits within the size limit, the process proceeds to Form packet, which organizes the (possibly fragmented) data into transmission-ready packets that include addressing, integrity checks, and sequence metadata. This ensures that the resulting packets can be efficiently propagated through the mesh. The Form packet use case is central to this process and is therefore included in both <Receive data> and <Break data into chunks>.

\subsubsection{Form packet}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{Images//Usecase Diagram/UD6.png}
    \caption{Usecase diagram: Form packet}
\end{figure}
The process begins when the device <Receives data/request>, which could originate from higher-level processes such as user input, fragmented data chunks, or control messages. This initial step triggers the packet formation process and is marked as an include relationship since it is always necessary for forming a packet.\\
After receiving the data, the system proceeds to <Fill out packet header>, where it constructs the essential components of the packet’s metadata — such as source and destination addresses, message type, sequence number, and other routing-related information. This header ensures that each packet can be properly routed through the mesh and identified upon reception.\\
The <Create signature through metadata> use case is shown as an extension of the header-filling step. This indicates that once the header is completed, the system may generate a digital signature or integrity check based on the metadata. This mechanism ensures authenticity and prevents tampering during transmission across multiple mesh hops.
To further enhance security, the <Encrypt data with session key> use case is introduced as another extended relationship. This step ensures that the payload is encrypted before transmission using a shared session key between peers. This encryption maintains confidentiality, ensuring that only authorized nodes can read the message contents even though the mesh operates as a distributed network.\\
Once the packet has been properly constructed, signed, and encrypted, it is ready to be transmitted. The Send packet to transport layer use case — connected via an include relationship — handles forwarding the completed packet to the underlying transport layer. This layer then manages the packet’s transmission across the mesh network, whether via unicast or broadcast, depending on the routing configuration.

\subsection{Activity Diagrams}
\begin{wrapfigure}{r}{0.6\textwidth}
  \begin{center}
    \includegraphics[width=0.2\textwidth]{Images//Activity Diagram/AD1.png}
  \end{center}
  \caption{Activity diagram: Bootstrapping}
\end{wrapfigure}
The app continuously scans nearby devices over Bluetooth and reads each peer’s basic info from advertisements/GATT while also broadcasting its own presence. When the user accepts a peer, the app fetches that peer’s network details (e.g., capabilities/keys), then updates a local peer cache with a fresh timestamp/TTL. If the user declines, the temporary record is discarded. The UI then displays the current list of discovered users. This loop repeats so the list stays up-to-date as devices appear or leave.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{Images//Activity Diagram/AD2.png}
    \caption{Activity diagram: Open communication channel}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Images//Activity Diagram/AD3.png}
    \caption{Activity diagram: Process message}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Images//Activity Diagram/AD4.png}
    \caption{Activity diagram: Send message}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Images//Activity Diagram/AD5.png}
    \caption{Activity diagram: Fragmentation}
\end{figure}
\begin{figure}[H]
    \centering  
    \includegraphics[width=0.5\linewidth]{Images//Activity Diagram/AD6.png}
    \caption{Activity diagram: Form package}
\end{figure}

\subsection{Sequence Diagrams}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Images//Sequence diagram/Bootstrapping.png}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Sequence diagram/Open communication channel.png}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Sequence diagram/Process message.png}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Sequence diagram/Send message.png}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Sequence diagram/Fragmentation.png}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images//Sequence diagram/Form Packet.png}
\end{figure}

\subsection{Deployment diagram}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Images/Deployment Diagram/Deployment Diagram.drawio.png}
\end{figure}
This diagram shows the execution architecture of the hardware system and the assignment of software artifacts to the hardware. Each device (smartphone) runs the app, which includes several components: Interface, Mesh manager, Encryption engine, Data cache (message queue, encryption keys, etc). Devices communicate directly using BLE in a mesh topology. The Mesh manager handles discovery, relaying, and routing of the package while the encryption engine keeps things private.
\newpage
\section{System Design}
\subsection{System Architecture}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\linewidth]{Images/SystemArchitecture.png}
\end{figure}
The system is structured into five interacting layers, each responsible for a set of tasks:

\begin{itemize}
    \item \textbf{Application layer}
    \begin{itemize}
        \item Provide user interface
        \item Manage notifications
    \end{itemize}

    \item \textbf{Presentation layer}
    \begin{itemize}
        \item Handle formatting
    \end{itemize}

    \item \textbf{Session layer}
    \begin{itemize}
        \item Maintain active peer connection across the mesh
        \item Control session establishment, routing, and sequencing between nodes
        \item Manage acknowledgements, retransmission, and relay within the mesh
    \end{itemize}

    \item \textbf{Security layer}
    \begin{itemize}
        \item Implement end-to-end (E2E) security using cryptographic protocols
        \item Manage keys, authentications, and data integrity
    \end{itemize}

    \item \textbf{Transport layer}
    \begin{itemize}
        \item Provide the BLE transport function
        \item Handle advertising, scanning, connection establishment, and packet delivery
    \end{itemize}
\end{itemize}

This architecture ensures that each function of the app is independent and replaceable, enhancing scalability and maintainability.

\subsection{Technology Selection}
\textbf{Why Kotlin?}

On the Android platform, Kotlin provides the most control over BLE and background executions, which is critical for reliability and battery life. Kotlin is also a modern and productive platform with a wide range of APIs and available documentation. Scaling path is also a big reason why we chose the platform; the app can be upgraded or moved to iOS with minimal work.

\textbf{Other Solutions}

Some other solutions that can provide similar services have many disadvantages that our system can overcome.

\begin{itemize}
    \item \textbf{Conventional Internet-based messaging apps:}
    \begin{itemize}
        \item Require internet or mobile data.
        \item Expose user metadata and routing paths to service providers.
        \item Stop functioning in offline or low-connectivity environments (disasters, protests, rural areas).
    \end{itemize}

    \item \textbf{Local Wi-Fi or Hotspot:}
    \begin{itemize}
        \item Only provide short-range offline messaging.
        \item High power consumption.
        \item Often requires manual connection.
    \end{itemize}

    \item \textbf{SMS or Radio communication:}
    \begin{itemize}
        \item Depend on pre-existing infrastructure.
        \item Not end-to-end encrypted, easily monitored or intercepted.
        \item Limited in data capacity and flexibility for file or image sharing.
    \end{itemize}
\end{itemize}

\textbf{Why Bluetooth Mesh is Superior}

\begin{itemize}
    \item \textbf{Fully Decentralized:} No servers, SIM cards, or internet needed. Every device becomes a node and relay, ensuring communication continues even when infrastructure fails.
    \item \textbf{End-to-End Encryption:} Messages remain private and secure, even when relayed through other users’ phones.
    \item \textbf{Energy-Efficient and Automatic:} Uses Bluetooth Low Energy (BLE) for background operation with minimal battery drain.
    \item \textbf{Resilient and Scalable Mesh:} Messages hop through nearby peers; the more peers, the more reliable and powerful the system becomes.
    \item \textbf{Privacy by Design:} No centralized storage or tracking; data stays local on the device.
    \item \textbf{Perfect for Offline Scenarios:} Ideal for natural disasters, remote areas, festivals, protests, or emergency conditions.
\end{itemize}
\newpage
\section{System Implementation}

\newpage


\section{System Evaluation}

\newpage
\section{Conclusion}
\subsection{Achievements}

\subsection{Limitations}
\subsection{Further improvements}

\newpage
% \section*{References}
\addcontentsline{toc}{section}{References}
% \bibliographystyle{apa}
% \bibliography{refs.bib} % Entries are in the refs.bib file
\printbibliography
\end{document}